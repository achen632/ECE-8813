# YOU DO NOT NEED TO MODIFY THIS FILE
# This file contains helper functions for interacting with the input data as well
# as the LLM

import requests
import pathlib
import json

import sys
import time
import threading

USERNAME = ""
LAST_4_DIGITS = ""
SUBMISSION_ID = "testing"

def generate_submission_key():
    import hashlib
    input_string = (USERNAME + LAST_4_DIGITS).encode('utf-8')
    submission_key = hashlib.sha256(input_string).hexdigest()
    return submission_key

def with_truncation(label, content, max_length=60) -> str:
    if len(content) > max_length:
        return f" * {label}: \"{content[:max_length]}\"..."
    else:
        return f" * {label}: \"{content}\""

def ask_agent(prompt, model="tngtech/deepseek-r1t2-chimera:free", temperature=0):
    assert USERNAME != "", "Please set your actual username."
    assert LAST_4_DIGITS != "", "Please set the last 4 digits of your student ID."

    url = "https://riposte-stu-20.storm.gatech.edu/api/run_prompt"
    payload = {
        "submission_key": generate_submission_key(),
        "submission_id": SUBMISSION_ID,
        "prompt": prompt,
        "model": model,
        "temperature": temperature
    }

    with TimerIndicator(with_truncation("Prompting LLM with", prompt)):
        try:

            network_response = requests.post(url, json=payload)
            print("")
            network_response.raise_for_status()
            llm_response = network_response.json().get("response")
            if llm_response:
                print("  " + with_truncation("Received response from agent", llm_response.strip(), max_length=80))
                return llm_response
            print(f"    ! No response received from agent. {network_response.json()}")
            return None
                
        except requests.RequestException as e:
            print(f"    ! Error occurred while asking agent: {e}")
            # Log the error details
            json = network_response.json()
            if 'error' in json:
                print("    ! Error details:", json['error'])
                if 'details' in json:
                    print("      ! Additional details:", json['details'])
            return None


def load_input_data(sample_number: int):
    # Sample number can be 1, 2, or 3
    assert sample_number in [1, 2, 3], "Sample number must be 1, 2, or 3."
    # Load static analysis data
    static_data_path = pathlib.Path(__file__).parent / f"sample_{sample_number}" / "static_disassembly.txt"
    with open(static_data_path, "r") as f:
        static_data = f.read()
    
    # Load dynamic analysis data
    dynamic_data_path = pathlib.Path(__file__).parent / f"sample_{sample_number}" / "dynamic_api_calls.json"
    with open(dynamic_data_path, "r") as f:
        api_calls = json.load(f)['behavior']

    return static_data, api_calls


class TimerIndicator:
    def __init__(self, message="Processing"):
        self.message = message
        self.start_time = None
        self._stop = threading.Event()
        self._thread = threading.Thread(target=self._update, daemon=True)

    def _update(self):
        assert self.start_time is not None, "TimerIndicator must be started with __enter__ before _update is called."
        while not self._stop.is_set():
            elapsed = time.time() - self.start_time
            sys.stdout.write(f"\r{self.message} {elapsed:5.1f}s elapsed")
            sys.stdout.flush()
            time.sleep(0.2)

    def __enter__(self):
        self.start_time = time.time()
        self._thread.start()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._stop.set()
        self._thread.join()
        sys.stdout.flush()

# YOU DO NOT NEED TO MODIFY THIS FILE